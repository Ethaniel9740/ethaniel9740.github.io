---
title: C++音视频HONOR外包
date: 2025-11-27 21:30:00
categories: 'InterviewSummary'
copyright_author: Ethaniel

---

### 问题1：C++语言面相对象，谈谈你对面相对象怎么理解？与面相过程有什么区别？

回答：
面向对象编程（OOP）是一种编程范式，它使用“对象”来设计软件。对象是类的实例，类定义了对象的属性和方法。OOP的核心概念包括封装、继承、多态和抽象。

- 封装：将数据和行为包装在一起，并隐藏内部实现细节，只暴露必要的接口。
- 继承：允许创建新的类（子类）从已有的类（父类）继承属性和方法，从而实现代码重用。
- 多态：允许不同的对象对同一消息做出不同的响应，通常通过虚函数实现。
- 抽象：忽略不必要的细节，只关注本质特征，通过抽象类和接口实现。

与面向过程编程（POP）的区别：

- 面向过程编程以函数为中心，将程序分解为一系列步骤，每个步骤由一个函数实现。数据与函数是分离的。
- 面向对象编程以对象为中心，将数据和对数据的操作封装在一起，更易于管理复杂的程序，提高代码的可重用性、

### 问题2：STL模版库有哪些？

回答：
STL（Standard Template Library）是C++标准库的一部分，提供了一系列通用的模板类和函数，主要包括：

- 容器（Containers）：用于存储数据的类模板，如vector、list、deque、set、map、unordered_set、unordered_map等。
- 算法（Algorithms）：用于操作容器中数据的函数模板，如排序、查找、遍历等，例如sort、find、for_each等。
- 迭代器（Iterators）：用于遍历容器中的元素，提供一种统一的方法来访问容器。
- 函数对象（Functors）：重载了函数调用运算符的类，可以像函数一样被调用。
- 适配器（Adapters）：包括容器适配器（如stack、queue、priority_queue）和迭代器适配器（如reverse_iterator）。

### 问题3：介绍一下动态数据vector实现的底层原理？

回答：
vector是动态数组，其底层实现是一段连续的内存空间。它通过三个指针来管理：

- `_start`：指向容器内第一个元素。
- `_finish`：指向最后一个元素的下一个位置。
- `_end_of_storage`：指向容器当前分配的内存空间的末尾。

当元素数量超过当前容量时，vector会进行重新分配：分配一块更大的内存（通常是当前容量的2倍或1.5倍），将原有元素复制到新内存，然后释放原有内存。这个过程称为重新分配（reallocation）。

### 问题4：以及动态数据vector和list链表的区别？

回答：

- 底层结构：vector是动态数组，连续内存；list是双向链表，非连续内存。
- 访问效率：vector支持随机访问，时间复杂度为O(1)；list不支持随机访问，访问元素需要遍历，时间复杂度为O(n)。
- 插入和删除：vector在尾部插入删除效率高，在中间或头部插入删除需要移动元素，效率低；list在任何位置插入删除效率都高，只需要修改指针。
- 内存分配：vector一次性分配连续内存，可能预留空间；list每次插入新元素都会分配节点内存。
- 空间占用：vector占用空间少，但可能浪费一部分预留空间；list每个节点需要额外指针空间。

### 问题5：动态数据vector和list链表适用于什么场景？（引申动态数据小数据，什么是小数据）

回答：

- vector适用于需要频繁随机访问、元素数量相对稳定、在尾部进行插入删除的场景。对于小数据，vector的连续内存访问效率高，缓存友好。
- list适用于需要频繁在任意位置插入删除、不需要随机访问的场景。

小数据通常指元素数量较少，例如几十个以内。对于小数据，vector由于连续存储，缓存命中率高，即使需要移动元素，开销也相对较小。而list的每个节点可能分散在内存中，缓存不友好，对于小数据，其动态分配的开销和缓存不友好的特性可能使得性能不如vector。

### 问题6：C++内存管理有哪些？怎么管理这些内存？

回答：
C++内存管理主要包括：

- 栈内存：由编译器自动管理，分配和释放局部变量。
- 堆内存：由程序员手动管理，使用new/delete或malloc/free分配和释放。
- 全局/静态存储区：存放全局变量和静态变量，程序开始时分配，程序结束时释放。
- 常量存储区：存放常量字符串等，程序结束时释放。

管理内存的方法：

- 使用new和delete操作符进行堆内存的分配和释放。
- 使用智能指针（如unique_ptr、shared_ptr）自动管理堆内存，避免内存泄漏。
- 遵循RAII（Resource Acquisition Is Initialization）原则，将资源管理封装在对象生命周期中。

### 问题7：C++11有哪些新特性？

回答：
C++11引入了很多新特性，包括：

- 自动类型推导（auto）
- 范围for循环
- 智能指针（unique_ptr、shared_ptr、weak_ptr）
- 右值引用和移动语义
- Lambda表达式
- 委托构造函数和继承构造函数
- 标准库线程支持（std::thread、std::mutex等）
- 变长模板参数（Variadic Templates）
- 常量表达式（constexpr）
- 空指针常量（nullptr）
- 静态断言（static_assert）
- 委托构造函数和继承构造函数
- 等等

### 问题8：熟悉那些算法？描述一下快排？

回答：
熟悉的算法包括排序算法（快速排序、归并排序、堆排序等）、查找算法（二分查找等）、图算法（DFS、BFS、Dijkstra等）等。

快速排序（Quick Sort）是一种分治算法。步骤：

1. 选择基准值（pivot）：从数组中选择一个元素作为基准。
2. 分区（partition）：重新排列数组，所有比基准值小的元素放在基准前面，比基准值大的放在后面。分区完成后，基准值处于最终位置。
3. 递归排序：递归地将小于基准值和大于基准值的子数组排序。

快速排序的平均时间复杂度为O(n log n)，最坏情况（已排序数组）为O(n^2)，但通过随机选择基准可以避免最坏情况。

### 问题9：熟悉那些设计模式，单例模式？

回答：
熟悉的设计模式包括单例模式、工厂模式、观察者模式、策略模式等。

单例模式确保一个类只有一个实例，并提供一个全局访问点。实现方式：

- 将构造函数设为私有，防止外部创建实例。
- 提供一个静态方法返回唯一实例。
- 在静态方法中，如果实例不存在则创建，否则返回已有实例。

注意：多线程环境下需要保证线程安全，可以使用双重检查锁定（Double-Checked Locking）或静态局部变量（C++11以后保证线程安全）。

### 问题10：进程和线程的区别？

回答：

- 进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位。
- 进程拥有独立的地址空间，线程共享进程的地址空间。
- 进程间通信需要IPC（如管道、消息队列、共享内存等），线程间通信可以直接读写进程数据段（如全局变量）。
- 进程上下文切换开销大，线程切换开销小。
- 一个进程崩溃不会影响其他进程，但一个线程崩溃可能导致整个进程崩溃。

### 问题11：多线程开发常见的问题是什么？

回答：
多线程开发常见问题包括：

- 竞态条件（Race Condition）：多个线程同时访问共享资源，结果取决于执行顺序。
- 死锁（Deadlock）：两个或多个线程互相等待对方释放资源。
- 活锁（Livelock）：线程不断改变状态以响应其他线程，但无法继续执行。
- 资源饥饿（Starvation）：某个线程无法获得所需资源，无法执行。
- 内存一致性错误：由于缓存不一致，线程看到的数据不是最新的。

解决方法：使用互斥锁、条件变量、原子操作、线程安全的数据结构等。

### 问题12：网络编程有哪些tcp协议和udp协议，tcp协议和udp有什么不同？

回答：
TCP（传输控制协议）和UDP（用户数据报协议）是传输层协议。

TCP：

- 面向连接：通信前需要建立连接。
- 可靠传输：通过确认、重传、流量控制、拥塞控制等机制保证数据可靠到达。
- 有序性：保证数据按发送顺序到达。
- 速度相对慢，开销大。

UDP：

- 无连接：不需要建立连接。
- 不可靠传输：不保证数据到达，不保证顺序。
- 速度快，开销小。

### 问题13：tcp协议和udp使用场景？

回答：

- TCP适用于需要可靠传输的场景，如文件传输、网页浏览、电子邮件等。
- UDP适用于对实时性要求高、允许少量数据丢失的场景，如视频流、语音通话、在线游戏等。

### 问题14：介绍你的项目遇见什么典型的问题？

### 问题15：C++结构体和联合体有什么区别？

回答：

- 结构体（struct）：每个成员拥有独立的内存空间，结构体的大小至少为所有成员大小之和（考虑内存对齐）。
- 联合体（union）：所有成员共享同一块内存空间，联合体的大小为最大成员的大小，同一时间只能使用一个成员。

### 问题16：虚函数和纯虚函数有什么区别？技术上的区别？

回答：

- 虚函数：在基类中使用virtual关键字声明的函数，派生类可以重写（override）它。基类可以提供虚函数的默认实现。
- 纯虚函数：在基类中声明为纯虚函数，使用`=0`语法，基类不提供实现，派生类必须实现纯虚函数。含有纯虚函数的类称为抽象类，不能实例化。

技术上的区别：纯虚函数使得类成为抽象类，强制派生类实现该函数。虚函数则允许派生类选择是否重写。

### 问题17：析构能否定义为虚函数？

回答：
可以，而且当基类指针指向派生类对象时，如果基类的析构函数不是虚函数，那么删除基类指针时只会调用基类的析构函数，导致派生类对象的部分资源没有被释放，造成内存泄漏。因此，如果类可能被继承，并且可能通过基类指针删除派生类对象，则基类的析构函数应该定义为虚函数

### 问题18：构造函数能否定义为虚函数？

回答：
不能。因为虚函数表（vtable）是在构造函数中初始化的，在构造函数调用时，对象的动态类型还没有确定，所以不能使用虚函数机制。

### 问题19：虚函数的实现原理是什么？

回答：
虚函数通过虚函数表（vtable）实现。每个含有虚函数的类都有一个虚函数表，其中存放了虚函数的地址。每个对象有一个指向虚函数表的指针（vptr）。当调用虚函数时，通过vptr找到虚函数表，再通过偏移量找到具体的函数地址进行调用。

### 问题20：C++里面深拷贝浅拷贝的区别？

回答：

- 浅拷贝：只复制指针的值，使得两个指针指向同一块内存。如果其中一个对象释放了内存，另一个对象的指针就成为野指针。
- 深拷贝：复制指针所指向的内存内容，使得两个对象拥有独立的内存空间。

### 问题21：栈和堆的区别是什么？

回答：

- 栈：由编译器自动管理，分配局部变量和函数参数。栈内存分配速度快，但空间有限。
- 堆：由程序员手动管理（new/delete或malloc/free），空间较大，分配速度慢，容易产生内存碎片。

### 问题22：C++定义一个空类，会默认生成几个成员函数？这个成员函数叫什么名字？

回答：
默认生成6个成员函数：

- 默认构造函数
- 拷贝构造函数
- 移动构造函数（C++11）
- 赋值运算符
- 移动赋值运算符（C++11）
- 析构函数

### 问题23：介绍一下什么叫多态？什么是静态多态？什么是动态多态的区别？

回答：
多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。

静态多态（编译时多态）：通过函数重载和模板实现，在编译时确定调用哪个函数。
动态多态（运行时多态）：通过虚函数和继承实现，在运行时根据对象的实际类型调用相应的函数。

### 问题24：指针和引用有什么区别？

回答：

- 指针是一个变量，存储地址，可以为空，可以改变指向；引用是别名，必须初始化，不能改变绑定。
- 指针可以多级（如指针的指针），引用只有一级。
- 指针需要解引用（*）来访问对象，引用直接使用。
- 指针可以参与算术运算，引用不能。

### 问题25：什么是野指针?

因为回答错误：理解也野指针有误，导致后面问题到我，再次调用这个野指针，这个指向的地址是否变化，每次调用是否变化？

回答：
野指针是指向无效内存的指针。产生原因：

- 指针未初始化。
- 指针指向的内存被释放后，没有置为nullptr。
- 指针操作越界。

再次调用野指针，其指向的地址可能不变，但该地址的内容可能已被其他代码修改，或者该地址可能已经不可访问，导致未定义行为。

### 问题26：野指针和内存泄漏的区别？

回答：

- 野指针：指针指向的内存无效，使用野指针会导致未定义行为。
- 内存泄漏：已分配的内存没有被释放，导致内存浪费，但指针可能已经丢失，无法再访问该内存。

### 问题27：什么是C++中的内存对齐？

回答：
内存对齐是指数据在内存中的地址必须是某个值的倍数（通常是数据类型大小的倍数）。这样可以提高CPU访问内存的效率。编译器会自动进行内存对齐，也可以使用#pragma pack等指令调整。

### 问题28：this指针是什么？

回答：
this指针是类成员函数中的一个隐藏参数，指向调用该成员函数的对象。在成员函数内部，可以通过this来访问当前对象的成员。

### 问题29：如果一个类里面有一个成员函数的话，它用static进行修饰了，是一个静态的。它能不能访问这个类里的成员变量那？

回答：
不能。静态成员函数没有this指针，因此只能访问静态成员变量和静态成员函数，不能访问非静态成员变量和非静态成员函数。
